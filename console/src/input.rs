//! This module handles input events from the user.
//! It defines the `Key` enum to represent different keys
//! and provides methods to convert byte sequences
//! to `Key` values.

/// The `Key` enum represents different keys
/// that can be pressed on the keyboard.
/// It includes letters, arrow keys,
/// space, enter, and backspace.
///
/// Some keys require a specific byte sequence
/// to be recognized, such as arrow keys.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Key {
    A,
    B,
    C,
    D,
    E,
    F,
    G,
    H,
    I,
    J,
    K,
    L,
    M,
    N,
    O,
    P,
    Q,
    R,
    S,
    T,
    U,
    V,
    W,
    X,
    Y,
    Z,
    Num0,
    Num1,
    Num2,
    Num3,
    Num4,
    Num5,
    Num6,
    Num7,
    Num8,
    Num9,
    Dot,
    Comma,
    Semicolon,
    Colon,
    Exclamation,
    Question,
    At,
    Hash,
    Dollar,
    Percent,
    Caret,
    Ampersand,
    Asterisk,
    ParenthesisLeft,
    ParenthesisRight,
    Minus,
    Plus,
    Underscore,
    Equals,
    BracketLeft,
    BracketRight,
    BraceLeft,
    BraceRight,
    Backslash,
    Quote,
    QuoteLeft,
    QuoteRight,
    Slash,
    Tilde,
    ArrowUp,
    ArrowDown,
    ArrowLeft,
    ArrowRight,
    Space,
    Enter,
    Backspace,
}

impl Key {
    pub fn from_byte(byte: u8) -> Self {
        match byte {
            b'a' => Key::A,
            b'b' => Key::B,
            b'c' => Key::C,
            b'd' => Key::D,
            b'e' => Key::E,
            b'f' => Key::F,
            b'g' => Key::G,
            b'h' => Key::H,
            b'i' => Key::I,
            b'j' => Key::J,
            b'k' => Key::K,
            b'l' => Key::L,
            b'm' => Key::M,
            b'n' => Key::N,
            b'o' => Key::O,
            b'p' => Key::P,
            b'q' => Key::Q,
            b'r' => Key::R,
            b's' => Key::S,
            b't' => Key::T,
            b'u' => Key::U,
            b'v' => Key::V,
            b'w' => Key::W,
            b'x' => Key::X,
            b'y' => Key::Y,
            b'z' => Key::Z,
            b'0' => Key::Num0,
            b'1' => Key::Num1,
            b'2' => Key::Num2,
            b'3' => Key::Num3,
            b'4' => Key::Num4,
            b'5' => Key::Num5,
            b'6' => Key::Num6,
            b'7' => Key::Num7,
            b'8' => Key::Num8,
            b'9' => Key::Num9,
            b'.' => Key::Dot,
            b',' => Key::Comma,
            b';' => Key::Semicolon,
            b':' => Key::Colon,
            b'!' => Key::Exclamation,
            b'?' => Key::Question,
            b'@' => Key::At,
            b'#' => Key::Hash,
            b'$' => Key::Dollar,
            b'%' => Key::Percent,
            b'^' => Key::Caret,
            b'&' => Key::Ampersand,
            b'*' => Key::Asterisk,
            b'(' => Key::ParenthesisLeft,
            b')' => Key::ParenthesisRight,
            b'-' => Key::Minus,
            b'+' => Key::Plus,
            b'_' => Key::Underscore,
            b'=' => Key::Equals,
            b'[' => Key::BracketLeft,
            b']' => Key::BracketRight,
            b'{' => Key::BraceLeft,
            b'}' => Key::BraceRight,
            b'\\' => Key::Backslash,
            b'\'' => Key::Quote,
            b'`' => Key::QuoteLeft,
            b'\"' => Key::QuoteRight,
            b'/' => Key::Slash,
            b'~' => Key::Tilde,
            b' ' => Key::Space,
            b'\n' => Key::Enter,
            b'\x7f' => Key::Backspace,

            _ => unreachable!(),
        }
    }

    pub fn from_bytes(buf: &[u8]) -> Option<Self> {
        match buf {
            [0x1b, 0x5b, 0x41] => Some(Key::ArrowUp),
            [0x1b, 0x5b, 0x42] => Some(Key::ArrowDown),
            [0x1b, 0x5b, 0x43] => Some(Key::ArrowRight),
            [0x1b, 0x5b, 0x44] => Some(Key::ArrowLeft),
            [byte] => match byte {
                b'a'..=b'z' => Some(Key::from_byte(*byte)),
                _ => None,
            },
            _ => None,
        }
    }
}
